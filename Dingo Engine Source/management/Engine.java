/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package management;

import Media.AdvancedMedia.Audio.DingoSoundDriver;
import Media.MediaPipeline;
import javafx.collections.ObservableList;
import javafx.event.Event;
import javafx.event.EventHandler;
import javafx.scene.Scene;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.layout.Pane;
import javafx.stage.Stage;
import motion.Animation;
import motion.Physics;
import objects.Entity;
import objects.Spawn;

/**
 *The main engine. Have your main class extend this class, then override all of the abstract methods.
 * @author James
 */
public abstract class Engine {
    private static final int MapVersion = 1;
    private static final String version = "1.5.0";
    private int fps;
    private ObservableList<Extension> extensions;
    private ObservableList<KeyMap> keys;
    public Stage stage;

    /**
     *reference this to use the Advanced Media package
     */
    public MediaPipeline media;
    
    /**
     *reference this to modify the animation timer object
     */
    public Timer animtimer;

    /**
     *The physics engine object. You reference this to make changes to the physics engine.
     */
    public Physics phy;
    private int preComputedRate;

    /**
     *call this to start the engine
     */
    public void start() {
        fps = 60;
        this.animtimer = new Timer(1000/fps) {
            @Override
            public void action() {
                frame2();
            }
        };
        animtimer.stop();
        extensions = javafx.collections.FXCollections.observableArrayList();
        keys = javafx.collections.FXCollections.observableArrayList();
        stage = new Stage();
        Scene s = new Scene(new Pane(), 1, 1);
        stage.setScene(s);
        stage.show();
        stage.setOnCloseRequest(new EventHandler() {
            @Override
            public void handle(Event event) {
                media.halt();
                System.exit(0);
            }
        });
        stage.setResizable(false);
        phy = new Physics() {

            @Override
            public void preTick() {
                frame();
                extensions.stream().forEach((extension) -> {
                    if(extension.isEnabled()){
                        extension.frame();
                    }
                    
                });
            }

            @Override
            public void postTick() {
                postPhysicsTick();
                extensions.stream().forEach((extension) -> {
                    if(extension.isEnabled()){
                        extension.postPhysicsTick();
                    }
                });
            }
            
            @Override
            public void collision(Entity e1, Entity e2) {
                onCollision(e1, e2);
                extensions.stream().forEach((extension) -> {
                    if(extension.isEnabled()){
                        extension.onCollision(e1, e2);
                    }
                });
            }

            @Override
            public void spawn(Spawn spawn, Entity e) {
                onSpawning(spawn, e);
                extensions.stream().forEach((extension) -> {
                    if(extension.isEnabled()){
                        extension.onSpawning(spawn, e);
                    }
                });
            }
        };
        this.init();
    }
    
    public void beginMediaSystem(int sampleRate, int bitDepth){
        media = new MediaPipeline();
        DingoSoundDriver DSD = new DingoSoundDriver();
        DSD.init(sampleRate, bitDepth, (sampleRate / fps) * (bitDepth / 8));
        media.setAudio(DSD);
        media.start();
        preComputedRate = sampleRate * (bitDepth / 8);
    }
    
    public int getComputedMediaBufferSize(){
        return preComputedRate / fps * 2;
    }
    /**
     *returns the compatible map structure version
     * @return
     */
    public static int getMapVersion() {
        return MapVersion;
    }
    
    /**
     *called every time a new frame is drawn.
     */
    public abstract void frame();
    
    /**
     *called every time a spawner wants to spawn.
     * @param spawn the corresponding spawner
     * @param e the entity object generated by the spawner
     */
    public abstract void onSpawning(Spawn spawn, Entity e);
    
    /**
     *called every time the physics engine finishes processing.
     */
    public abstract void postPhysicsTick();
    
    /**
     *called whenever a collision is detected.
     * @param e1
     * @param e2
     */
    public abstract void onCollision(Entity e1, Entity e2);
    
    /**
     *called in your main class. put all of your startup code in here
     */
    public abstract void init();
    
    /**
     * Called when the internal KeyMapper detects a key press
     * @param key The key that was pressed
     */
    public abstract void KeyPressed(String key);
    
    /**
     * Called when the internal KeyMapper detects a key release
     * @param key The key that was released
     */
    public abstract void KeyReleased(String key);
    
    private void frame2(){
        phy.check();
        Animation.nextFrames();
        if (media != null) {
            media.process();
        }
        TimeQueue.masterCheck();
    }
    
    /**
     *
     * @return the set FPS (does NOT return the actual FPS)
     */
    public int getFps() {
        return fps;
    }
    
    /**
     *Sets the engine's timing. Changing this changes the speed of the game itself.
     * @param fps
     */
    public void setFps(int fps) {
        this.fps = fps;
        animtimer.setInterval(1000/fps);
    }
    
    /**
     *starts/stops the animation timer.
     * @param run
     */
    public void setRunning(boolean run){
        if(run){
            animtimer.start();
        }else{
            animtimer.stop();
        }
    }

    /**
     *returns the engine's version
     * @return
     */
    public static String getVersion() {
        return version;
    }
    
    /**
     * Adds an extension class to the Engine
     * @param ext The extension class to add
     */
    public void addExtension(Extension ext){
        extensions.add(ext);
        ext.setEngine(this);
        ext.init();
    }
    
    /**
     * Removes an extension class from the Engine
     * @param ext The extension class to remove
     */
    public void removeExtension(Extension ext){
        extensions.remove(ext);
        ext.detach();
    }
    
    /**
     * Registers a scene to the Engine's internal KeyMapper
     * @param s The scene to register to the KeyMapper
     */
    public void registerKeyMap(Scene s){
        s.setOnKeyPressed(new EventHandler<KeyEvent>() {
            @Override
            public void handle(KeyEvent event) {
                for (KeyMap key : keys) {
                    if(event.getCode() == key.getCode()){
                        KeyPressed(key.getKey());
                        extensions.stream().filter((ext) -> (ext.isEnabled())).forEach((ext) -> {
                            ext.KeyPressed(key.getKey());
                        });
                    }
                }
            }
        });
        s.setOnKeyReleased(new EventHandler<KeyEvent>() {
            @Override
            public void handle(KeyEvent event) {
                for (KeyMap key : keys) {
                    if(event.getCode() == key.getCode()){
                        KeyReleased(key.getKey());
                        extensions.stream().filter((ext) -> (ext.isEnabled())).forEach((ext) -> {
                            ext.KeyReleased(key.getKey());
                        });
                    }
                }
            }
        });
    }
    
    /**
     * Maps a new key to the internal Key Mapper
     * @param code
     * @param key
     */
    public void addKey(KeyCode code, String key){
        keys.add(new KeyMap(key, code));
    }
    
    /**
     * Removes a key mapping based by KeyCode
     * @param code
     */
    public void removeKey(KeyCode code){
        int size = keys.size();
        for (int i = 0; i < size; i++) {
            if(keys.get(i).getCode() == code){
                keys.remove(i);
                size = keys.size();
            }
        }
    }
    
    /**
     * Removes a key mapping based by Key
     * @param key
     */
    public void removeKey(String key){
        int size = keys.size();
        for (int i = 0; i < size; i++) {
            if(keys.get(i).getKey() == null ? key == null : keys.get(i).getKey().equals(key)){
                keys.remove(i);
                size = keys.size();
            }
        }
    }
    
    private class KeyMap{
        private final KeyCode code;
        private final String key;
        
        public KeyMap(String key, KeyCode code) {
            this.code = code;
            this.key = key;
        }

        public KeyCode getCode() {
            return code;
        }

        public String getKey() {
            return key;
        }
    }
}
